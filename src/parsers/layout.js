/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */
(function(root, factory) {
	if (typeof define === "function" && define.amd) {
		define([], factory);
	} else if (typeof module === "object" && module.exports) {
		module.exports = factory();
	} else {
		root.module.exports = factory();
	}
})(this, function() {
	"use strict";

	function peg$subclass(child, parent) {
		function ctor() {
			this.constructor = child;
		}

		ctor.prototype = parent.prototype;
		child.prototype = new ctor();
	}

	function peg$SyntaxError(message, expected, found, location) {
		this.message = message;
		this.expected = expected;
		this.found = found;
		this.location = location;
		this.name = "SyntaxError";

		if (typeof Error.captureStackTrace === "function") {
			Error.captureStackTrace(this, peg$SyntaxError);
		}
	}

	peg$subclass(peg$SyntaxError, Error);

	peg$SyntaxError.buildMessage = function(expected, found) {
		const DESCRIBE_EXPECTATION_FNS = {
			literal(expectation) {
				return '"' + literalEscape(expectation.text) + '"';
			},

			class(expectation) {
				let escapedParts = "";
				let i;

				for (i = 0; i < expectation.parts.length; i++) {
					escapedParts += Array.isArray(expectation.parts[i])
						? classEscape(expectation.parts[i][0]) +
						  "-" +
						  classEscape(expectation.parts[i][1])
						: classEscape(expectation.parts[i]);
				}

				return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
			},

			any(expectation) {
				return "any character";
			},

			end(expectation) {
				return "end of input";
			},

			other(expectation) {
				return expectation.description;
			},
		};

		function hex(ch) {
			return ch
				.charCodeAt(0)
				.toString(16)
				.toUpperCase();
		}

		function literalEscape(s) {
			return s
				.replace(/\\/g, "\\\\")
				.replace(/"/g, '\\"')
				.replace(/\0/g, "\\0")
				.replace(/\t/g, "\\t")
				.replace(/\n/g, "\\n")
				.replace(/\r/g, "\\r")
				.replace(/[\u0000-\u000F]/g, function(ch) {
					return "\\x0" + hex(ch);
				})
				.replace(/[\u0010-\u001F\u007F-\u009F]/g, function(ch) {
					return "\\x" + hex(ch);
				});
		}

		function classEscape(s) {
			return s
				.replace(/\\/g, "\\\\")
				.replace(/]/g, "\\]")
				.replace(/\^/g, "\\^")
				.replace(/-/g, "\\-")
				.replace(/\0/g, "\\0")
				.replace(/\t/g, "\\t")
				.replace(/\n/g, "\\n")
				.replace(/\r/g, "\\r")
				.replace(/[\u0000-\u000F]/g, function(ch) {
					return "\\x0" + hex(ch);
				})
				.replace(/[\u0010-\u001F\u007F-\u009F]/g, function(ch) {
					return "\\x" + hex(ch);
				});
		}

		function describeExpectation(expectation) {
			return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
		}

		function describeExpected(expected) {
			const descriptions = new Array(expected.length);
			let i;
			let j;

			for (i = 0; i < expected.length; i++) {
				descriptions[i] = describeExpectation(expected[i]);
			}

			descriptions.sort();

			if (descriptions.length > 0) {
				for (i = 1, j = 1; i < descriptions.length; i++) {
					if (descriptions[i - 1] !== descriptions[i]) {
						descriptions[j] = descriptions[i];
						j++;
					}
				}

				descriptions.length = j;
			}

			switch (descriptions.length) {
				case 1:
					return descriptions[0];

				case 2:
					return descriptions[0] + " or " + descriptions[1];

				default:
					return (
						descriptions.slice(0, -1).join(", ") +
						", or " +
						descriptions[descriptions.length - 1]
					);
			}
		}

		function describeFound(found) {
			return found ? '"' + literalEscape(found) + '"' : "end of input";
		}

		return (
			"Expected " +
			describeExpected(expected) +
			" but " +
			describeFound(found) +
			" found."
		);
	};

	function peg$parse(input, options) {
		options = options !== void 0 ? options : {};

		const peg$FAILED = {};

		const peg$startRuleFunctions = { Root: peg$parseRoot };
		let peg$startRuleFunction = peg$parseRoot;

		const peg$c0 = "";
		const peg$c1 = function() {
			return null;
		};

		const peg$c2 = function(view, size) {
			return { view, size };
		};

		const peg$c3 = "(";
		const peg$c4 = peg$literalExpectation("(", false);
		const peg$c5 = ")";
		const peg$c6 = peg$literalExpectation(")", false);
		const peg$c7 = function(inner) {
			return inner;
		};

		const peg$c8 = function(a, splits) {
			if (!splits) return a.view;
			const views = [a].concat(splits.views);
			const defaultSize =
				(100 - views.reduce((a, v) => a + v.size, 0)) /
				views.filter(v => !v.size).length;
			views.forEach(v => (v.size = v.size || defaultSize));
			return { sep: splits.sep, views };
		};

		const peg$c9 = "/";
		const peg$c10 = peg$literalExpectation("/", false);
		const peg$c11 = function(v) {
			return v;
		};

		const peg$c12 = function(views) {
			return { sep: "/", views };
		};

		const peg$c13 = "-";
		const peg$c14 = peg$literalExpectation("-", false);
		const peg$c15 = function(views) {
			return { sep: "-", views };
		};

		const peg$c16 = peg$otherExpectation(
			"view name (consisting of alphabetic characters)"
		);
		const peg$c17 = /^[a-zA-Z]/;
		const peg$c18 = peg$classExpectation(
			[
				["a", "z"],
				["A", "Z"],
			],
			false,
			false
		);
		const peg$c19 = function() {
			return text();
		};

		const peg$c20 = peg$otherExpectation(
			"size specifier (number between 0 and 100)"
		);
		const peg$c21 = /^\d/;
		const peg$c22 = peg$classExpectation([["0", "9"]], false, false);
		const peg$c23 = function() {
			return parseInt(text(), 10);
		};

		let peg$currPos = 0;
		let peg$savedPos = 0;
		const peg$posDetailsCache = [{ line: 1, column: 1 }];
		let peg$maxFailPos = 0;
		let peg$maxFailExpected = [];
		let peg$silentFails = 0;

		let peg$result;

		if ("startRule" in options) {
			if (!(options.startRule in peg$startRuleFunctions)) {
				throw new Error(
					'Canâ€™t start parsing from rule "' + options.startRule + '".'
				);
			}

			peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
		}

		function text() {
			return input.substring(peg$savedPos, peg$currPos);
		}

		function location() {
			return peg$computeLocation(peg$savedPos, peg$currPos);
		}

		function expected(description, location) {
			location =
				location !== void 0
					? location
					: peg$computeLocation(peg$savedPos, peg$currPos);

			throw peg$buildStructuredError(
				[peg$otherExpectation(description)],
				input.substring(peg$savedPos, peg$currPos),
				location
			);
		}

		function error(message, location) {
			location =
				location !== void 0
					? location
					: peg$computeLocation(peg$savedPos, peg$currPos);

			throw peg$buildSimpleError(message, location);
		}

		function peg$literalExpectation(text, ignoreCase) {
			return { type: "literal", text, ignoreCase };
		}

		function peg$classExpectation(parts, inverted, ignoreCase) {
			return {
				type: "class",
				parts,
				inverted,
				ignoreCase,
			};
		}

		function peg$anyExpectation() {
			return { type: "any" };
		}

		function peg$endExpectation() {
			return { type: "end" };
		}

		function peg$otherExpectation(description) {
			return { type: "other", description };
		}

		function peg$computePosDetails(pos) {
			let details = peg$posDetailsCache[pos];
			let p;

			if (details) {
				return details;
			}

			p = pos - 1;
			while (!peg$posDetailsCache[p]) {
				p--;
			}

			details = peg$posDetailsCache[p];
			details = {
				line: details.line,
				column: details.column,
			};

			while (p < pos) {
				if (input.charCodeAt(p) === 10) {
					details.line++;
					details.column = 1;
				} else {
					details.column++;
				}

				p++;
			}

			peg$posDetailsCache[pos] = details;
			return details;
		}

		function peg$computeLocation(startPos, endPos) {
			const startPosDetails = peg$computePosDetails(startPos);
			const endPosDetails = peg$computePosDetails(endPos);

			return {
				start: {
					offset: startPos,
					line: startPosDetails.line,
					column: startPosDetails.column,
				},
				end: {
					offset: endPos,
					line: endPosDetails.line,
					column: endPosDetails.column,
				},
			};
		}

		function peg$fail(expected) {
			if (peg$currPos < peg$maxFailPos) {
				return;
			}

			if (peg$currPos > peg$maxFailPos) {
				peg$maxFailPos = peg$currPos;
				peg$maxFailExpected = [];
			}

			peg$maxFailExpected.push(expected);
		}

		function peg$buildSimpleError(message, location) {
			return new peg$SyntaxError(message, null, null, location);
		}

		function peg$buildStructuredError(expected, found, location) {
			return new peg$SyntaxError(
				peg$SyntaxError.buildMessage(expected, found),
				expected,
				found,
				location
			);
		}

		function peg$parseRoot() {
			let s0;

			s0 = peg$parseUnparenthesized();
			if (s0 === peg$FAILED) {
				s0 = peg$parseEmpty();
			}

			return s0;
		}

		function peg$parseEmpty() {
			let s0;
			let s1;

			s0 = peg$currPos;
			s1 = peg$c0;
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c1();
			}

			s0 = s1;

			return s0;
		}

		function peg$parseView() {
			let s0;
			let s1;
			let s2;

			s0 = peg$currPos;
			s1 = peg$parseParenthesized();
			if (s1 === peg$FAILED) {
				s1 = peg$parseName();
			}

			if (s1 !== peg$FAILED) {
				s2 = peg$parseSize();
				if (s2 === peg$FAILED) {
					s2 = null;
				}

				if (s2 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c2(s1, s2);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}

			return s0;
		}

		function peg$parseParenthesized() {
			let s0;
			let s1;
			let s2;
			let s3;

			s0 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 40) {
				s1 = peg$c3;
				peg$currPos++;
			} else {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c4);
				}
			}

			if (s1 !== peg$FAILED) {
				s2 = peg$parseUnparenthesized();
				if (s2 !== peg$FAILED) {
					if (input.charCodeAt(peg$currPos) === 41) {
						s3 = peg$c5;
						peg$currPos++;
					} else {
						s3 = peg$FAILED;
						if (peg$silentFails === 0) {
							peg$fail(peg$c6);
						}
					}

					if (s3 !== peg$FAILED) {
						peg$savedPos = s0;
						s1 = peg$c7(s2);
						s0 = s1;
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}

			return s0;
		}

		function peg$parseUnparenthesized() {
			let s0;
			let s1;
			let s2;

			s0 = peg$currPos;
			s1 = peg$parseView();
			if (s1 !== peg$FAILED) {
				s2 = peg$parseVerticalSplits();
				if (s2 === peg$FAILED) {
					s2 = peg$parseHorizontalSplits();
				}

				if (s2 === peg$FAILED) {
					s2 = null;
				}

				if (s2 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c8(s1, s2);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}

			return s0;
		}

		function peg$parseVerticalSplits() {
			let s0;
			let s1;
			let s2;
			let s3;
			let s4;

			s0 = peg$currPos;
			s1 = [];
			s2 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 47) {
				s3 = peg$c9;
				peg$currPos++;
			} else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c10);
				}
			}

			if (s3 !== peg$FAILED) {
				s4 = peg$parseView();
				if (s4 !== peg$FAILED) {
					peg$savedPos = s2;
					s3 = peg$c11(s4);
					s2 = s3;
				} else {
					peg$currPos = s2;
					s2 = peg$FAILED;
				}
			} else {
				peg$currPos = s2;
				s2 = peg$FAILED;
			}

			if (s2 !== peg$FAILED) {
				while (s2 !== peg$FAILED) {
					s1.push(s2);
					s2 = peg$currPos;
					if (input.charCodeAt(peg$currPos) === 47) {
						s3 = peg$c9;
						peg$currPos++;
					} else {
						s3 = peg$FAILED;
						if (peg$silentFails === 0) {
							peg$fail(peg$c10);
						}
					}

					if (s3 !== peg$FAILED) {
						s4 = peg$parseView();
						if (s4 !== peg$FAILED) {
							peg$savedPos = s2;
							s3 = peg$c11(s4);
							s2 = s3;
						} else {
							peg$currPos = s2;
							s2 = peg$FAILED;
						}
					} else {
						peg$currPos = s2;
						s2 = peg$FAILED;
					}
				}
			} else {
				s1 = peg$FAILED;
			}

			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c12(s1);
			}

			s0 = s1;

			return s0;
		}

		function peg$parseHorizontalSplits() {
			let s0;
			let s1;
			let s2;
			let s3;
			let s4;

			s0 = peg$currPos;
			s1 = [];
			s2 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 45) {
				s3 = peg$c13;
				peg$currPos++;
			} else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c14);
				}
			}

			if (s3 !== peg$FAILED) {
				s4 = peg$parseView();
				if (s4 !== peg$FAILED) {
					peg$savedPos = s2;
					s3 = peg$c11(s4);
					s2 = s3;
				} else {
					peg$currPos = s2;
					s2 = peg$FAILED;
				}
			} else {
				peg$currPos = s2;
				s2 = peg$FAILED;
			}

			if (s2 !== peg$FAILED) {
				while (s2 !== peg$FAILED) {
					s1.push(s2);
					s2 = peg$currPos;
					if (input.charCodeAt(peg$currPos) === 45) {
						s3 = peg$c13;
						peg$currPos++;
					} else {
						s3 = peg$FAILED;
						if (peg$silentFails === 0) {
							peg$fail(peg$c14);
						}
					}

					if (s3 !== peg$FAILED) {
						s4 = peg$parseView();
						if (s4 !== peg$FAILED) {
							peg$savedPos = s2;
							s3 = peg$c11(s4);
							s2 = s3;
						} else {
							peg$currPos = s2;
							s2 = peg$FAILED;
						}
					} else {
						peg$currPos = s2;
						s2 = peg$FAILED;
					}
				}
			} else {
				s1 = peg$FAILED;
			}

			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c15(s1);
			}

			s0 = s1;

			return s0;
		}

		function peg$parseName() {
			let s0;
			let s1;
			let s2;

			peg$silentFails++;
			s0 = peg$currPos;
			s1 = [];
			if (peg$c17.test(input.charAt(peg$currPos))) {
				s2 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c18);
				}
			}

			if (s2 !== peg$FAILED) {
				while (s2 !== peg$FAILED) {
					s1.push(s2);
					if (peg$c17.test(input.charAt(peg$currPos))) {
						s2 = input.charAt(peg$currPos);
						peg$currPos++;
					} else {
						s2 = peg$FAILED;
						if (peg$silentFails === 0) {
							peg$fail(peg$c18);
						}
					}
				}
			} else {
				s1 = peg$FAILED;
			}

			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c19();
			}

			s0 = s1;
			peg$silentFails--;
			if (s0 === peg$FAILED) {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c16);
				}
			}

			return s0;
		}

		function peg$parseSize() {
			let s0;
			let s1;
			let s2;

			peg$silentFails++;
			s0 = peg$currPos;
			s1 = [];
			if (peg$c21.test(input.charAt(peg$currPos))) {
				s2 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c22);
				}
			}

			if (s2 !== peg$FAILED) {
				while (s2 !== peg$FAILED) {
					s1.push(s2);
					if (peg$c21.test(input.charAt(peg$currPos))) {
						s2 = input.charAt(peg$currPos);
						peg$currPos++;
					} else {
						s2 = peg$FAILED;
						if (peg$silentFails === 0) {
							peg$fail(peg$c22);
						}
					}
				}
			} else {
				s1 = peg$FAILED;
			}

			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c23();
			}

			s0 = s1;
			peg$silentFails--;
			if (s0 === peg$FAILED) {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c20);
				}
			}

			return s0;
		}

		peg$result = peg$startRuleFunction();

		if (peg$result !== peg$FAILED && peg$currPos === input.length) {
			return peg$result;
		}

		if (peg$result !== peg$FAILED && peg$currPos < input.length) {
			peg$fail(peg$endExpectation());
		}

		throw peg$buildStructuredError(
			peg$maxFailExpected,
			peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
			peg$maxFailPos < input.length
				? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
				: peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
		);
	}

	return {
		SyntaxError: peg$SyntaxError,
		parse: peg$parse,
	};
});
